数据分析平台 - 后端开发计划 (v2.0 - 优化与扩展)
项目定位: 基于现有 Supabase 架构，进行少量、精准的优化和扩展，以支持下一阶段全功能前端应用的开发。
核心原则: 将复杂计算左移到后端。 通过视图和 Edge Functions 为前端提供规整、即取即用的数据，最大限度减轻前端的计算负担。
Sprint B1: 核心功能函数化与自动化
目标: 将前端最复杂的计算需求封装成 Edge Functions，并实现系统的自动化运行。
任务 ID	✅	任务描述	详细执行步骤与代码/配置示例	验收标准
B-1.1	☐	(新建) 创建转化漏斗计算函数	目的: 为仪表盘的转化漏-斗图提供聚合数据。<br>动作: 创建一个新的 Edge Function get-conversion-funnel。<br>1. 本地创建: supabase functions new get-conversion-funnel<br>2. 编写 index.ts:<br> typescript<br> // ... (import, cors, client setup) ...<br> const { startDate, endDate } = await req.json();<br><br> // 假设你的 raw_ga4_data 中有 user_pseudo_id 和 event_name<br> const { data: funnelData, error } = await supabase.rpc('calculate_funnel', {<br> start_date: startDate,<br> end_date: endDate<br> });<br><br> if (error) throw error;<br><br> return new Response(JSON.stringify(funnelData), ...);<br><br>3. 创建对应的 PostgreSQL 函数 calculate_funnel: 这是 Edge Function 调用的核心逻辑，性能更高。<br> sql<br> CREATE OR REPLACE FUNCTION calculate_funnel(start_date date, end_date date)<br> RETURNS JSONB AS $$<br> DECLARE<br> total_visitors BIGINT;<br> view_product BIGINT;<br> add_to_cart BIGINT;<br> begin_checkout BIGINT;<br> BEGIN<br> -- Replace with your actual event names and logic<br> SELECT COUNT(DISTINCT user_pseudo_id) INTO total_visitors FROM public.raw_ga4_data WHERE date BETWEEN start_date AND end_date;<br> SELECT COUNT(DISTINCT user_pseudo_id) INTO view_product FROM public.raw_ga4_data WHERE event_name = 'view_item' AND date BETWEEN start_date AND end_date;<br> SELECT COUNT(DISTINCT user_pseudo_id) INTO add_to_cart FROM public.raw_ga4_data WHERE event_name = 'add_to_cart' AND date BETWEEN start_date AND end_date;<br> SELECT COUNT(DISTINCT user_pseudo_id) INTO begin_checkout FROM public.raw_ga4_data WHERE event_name = 'begin_checkout' AND date BETWEEN start_date AND end_date;<br><br> RETURN jsonb_build_object(<br> 'stages', jsonb_build_array(<br> jsonb_build_object('name', '访问用户', 'value', total_visitors),<br> jsonb_build_object('name', '浏览商品', 'value', view_product),<br> jsonb_build_object('name', '加入购物车', 'value', add_to_cart),<br> jsonb_build_object('name', '开始结账', 'value', begin_checkout)<br> )<br> );<br> END;<br> $$ LANGUAGE plpgsql;<br><br>4. 部署: supabase functions deploy get-conversion-funnel	函数部署成功。通过 Postman 或 curl 调用该函数并传入日期范围，能返回一个包含各漏斗阶段名称和数值的 JSON 对象。
B-1.2	☐	(优化) 适配按需同步功能	目的: 允许前端只触发特定数据源的同步。<br>动作: 修改现有的 Edge Function sync-external-data。<br>1. 修改 index.ts:<br> ```typescript<br> // ...<br> const body = await req.json().catch(() => ({})); // Gracefully handle no body<br> const sourcesToSync = body.sources	
B-1.3	☐	(新建) 设置自动化 Cron 任务	目的: 实现每日数据的自动全量同步。<br>动作: 使用 pg_cron 扩展。<br>1. 确认扩展启用: 在 Supabase Database -> Extensions 确认 pg_cron 已启用。<br>2. 创建调度: 在 SQL Editor 中执行：<br> sql<br> -- Schedule a job to run at 2:00 AM Hong Kong time (18:00 UTC the previous day)<br> SELECT cron.schedule(<br> 'daily-full-data-sync', -- A unique name for the job<br> '0 18 * * *', -- Cron syntax for 18:00 UTC<br> $$<br> SELECT net.http_post(<br> url:='https://<your-project-ref>.supabase.co/functions/v1/sync-external-data',<br> headers:='{"Authorization": "Bearer <your-service-role-key>"}'::jsonb,<br> body:='{}'::jsonb -- Empty body for full sync<br> );<br> $$<br> );<br><br> 安全提示: service_role_key 存储在 cron.job 表中，请确保该表的访问权限安全。	定时任务创建成功。可以在 cron.job 表中看到该任务。数据在每日指定时间会自动进行全量同步。
Sprint B2: 数据模型扩展与洞察增强
目标: 扩展数据模型以支持更高级的交互功能，并为前端提供更丰富的上下文数据。
任务 ID	✅	任务描述	详细执行步骤与技术细节	验收标准
B-2.1	☐	(扩展) 增强 recommendations 表	目的: 支持行动建议的任务分配和效果反馈。<br>动作: 通过数据库迁移脚本或在 SQL Editor 中执行 ALTER TABLE。<br> sql<br> ALTER TABLE public.recommendations<br> ADD COLUMN IF NOT EXISTS assignee_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,<br> ADD COLUMN IF NOT EXISTS due_date DATE,<br> ADD COLUMN IF NOT EXISTS feedback TEXT;<br><br> COMMENT ON COLUMN public.recommendations.assignee_id IS 'ID of the user responsible for this action.';<br> COMMENT ON COLUMN public.recommendations.due_date IS 'Target completion date for the recommendation.';<br> COMMENT ON COLUMN public.recommendations.feedback IS 'User feedback on the effectiveness of the action.';<br><br>动作2: 更新 RLS 策略<br> sql<br> -- 允许负责人或创建者更新建议<br> DROP POLICY IF EXISTS "Allow users to update their assigned recommendations" ON public.recommendations;<br> CREATE POLICY "Allow update by assignee or creator" ON public.recommendations FOR UPDATE<br> USING (auth.uid() = assignee_id OR auth.uid() = (SELECT user_id FROM insights WHERE id = insight_id));<br>	表结构更新成功，新的字段 (assignee_id, due_date, feedback) 已添加。RLS 策略已更新，保证了正确的写入权限。
B-2.2	☐	(新建) 创建洞察详情数据函数	目的: 为洞察详情页提供一站式的数据，避免前端多次请求。<br>动作: 创建一个新的 Edge Function get-insight-details。<br>1. 本地创建: supabase functions new get-insight-details<br>2. 编写 index.ts:<br> typescript<br> // ...<br> const { insightId } = await req.json();<br><br> // 1. Fetch the main insight and its recommendations<br> const { data: insightData, error: insightError } = await supabase<br> .from('insights')<br> .select('*, recommendations(*)')<br> .eq('id', insightId)<br> .single();<br> if (insightError) throw insightError;<br><br> // 2. Based on insight content, fetch relevant raw data snapshot<br> // This is a simplified example. Real logic might parse insight summary.<br> const { data: contextData, error: contextError } = await supabase<br> .from('daily_summary') // Or another relevant view/table<br> .select('*')<br> .order('date', { ascending: false })<br> .limit(7);<br> if (contextError) throw contextError;<br><br> const responsePayload = {<br> insight: insightData,<br> context_data: contextData<br> };<br><br> return new Response(JSON.stringify(responsePayload), ...);<br><br>3. 部署: supabase functions deploy get-insight-details	函数部署成功。调用时传入一个 insight_id，能返回一个包含该洞察、其所有建议以及相关上下文数据（如过去7天的摘要）的 JSON 对象。
B-2.3	☐	(验证) 检查所有视图性能	目的: 确保所有现有的数据库视图 (daily_summary, page_optimization_view 等) 在数据量增大时依然高效。<br>动作: <br>1. 使用 EXPLAIN (ANALYZE, BUFFERS) 运行每个视图的查询。<br> EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM public.daily_kpi_summary_view WHERE date BETWEEN '2023-10-01' AND '2023-10-31';<br>2. 分析查询计划: 检查是否存在全表扫描 (Seq Scan) 在大表上。如果存在，考虑在底层的 raw_ 表的相应字段上添加索引。<br>3. 例如: 如果 daily_kpi_summary_view 在 raw_woocommerce_orders 上的查询慢，检查 (order_data->>'date_created')::date 是否可以被索引，或者 status 字段是否有索引。	所有核心视图的查询计划都合理，执行时间在可接受范围内（例如 < 500ms），没有明显的性能瓶颈。
这份极其详尽的后端开发计划为你提供了未来几个 Sprint 清晰、可执行的任务。它完全基于你已有的坚实基础，通过精准的扩展和优化，为下一代功能强大的前端应用铺平了道路。